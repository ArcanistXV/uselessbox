
useless-box.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  000004b0  00000544  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004b0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800110  00800110  00000554  2**0
                  ALLOC
  3 .debug_aranges 00000080  00000000  00000000  00000554  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000162  00000000  00000000  000005d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000ad5  00000000  00000000  00000736  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000045d  00000000  00000000  0000120b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a09  00000000  00000000  00001668  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000150  00000000  00000000  00002074  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000214  00000000  00000000  000021c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000031d  00000000  00000000  000023d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002a0  00000000  00000000  000026f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 eb       	ldi	r30, 0xB0	; 176
  a0:	f4 e0       	ldi	r31, 0x04	; 4
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 31       	cpi	r26, 0x10	; 16
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a0 e1       	ldi	r26, 0x10	; 16
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a2 31       	cpi	r26, 0x12	; 18
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 75 00 	call	0xea	; 0xea <main>
  c6:	0c 94 56 02 	jmp	0x4ac	; 0x4ac <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <sleep>:
	//while(1); //end

}


void sleep(int ms){
  ce:	20 e0       	ldi	r18, 0x00	; 0
  d0:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  d2:	40 ea       	ldi	r20, 0xA0	; 160
  d4:	5f e0       	ldi	r21, 0x0F	; 15
  d6:	05 c0       	rjmp	.+10     	; 0xe2 <sleep+0x14>
  d8:	fa 01       	movw	r30, r20
  da:	31 97       	sbiw	r30, 0x01	; 1
  dc:	f1 f7       	brne	.-4      	; 0xda <sleep+0xc>
	
	for (int i = 0; i < ms; i++){
  de:	2f 5f       	subi	r18, 0xFF	; 255
  e0:	3f 4f       	sbci	r19, 0xFF	; 255
  e2:	28 17       	cp	r18, r24
  e4:	39 07       	cpc	r19, r25
  e6:	c4 f3       	brlt	.-16     	; 0xd8 <sleep+0xa>
		 _delay_ms(1);
		}
}
  e8:	08 95       	ret

000000ea <main>:

//declare global variables



 int main(){
  ea:	ef 92       	push	r14
  ec:	ff 92       	push	r15
  ee:	1f 93       	push	r17
  f0:	df 93       	push	r29
  f2:	cf 93       	push	r28
  f4:	cd b7       	in	r28, 0x3d	; 61
  f6:	de b7       	in	r29, 0x3e	; 62
  f8:	60 97       	sbiw	r28, 0x10	; 16
  fa:	0f b6       	in	r0, 0x3f	; 63
  fc:	f8 94       	cli
  fe:	de bf       	out	0x3e, r29	; 62
 100:	0f be       	out	0x3f, r0	; 63
 102:	cd bf       	out	0x3d, r28	; 61
	
	int swNpos[8] = {425, 525, 620, 700, 780, 880, 960, 1040};
 104:	de 01       	movw	r26, r28
 106:	11 96       	adiw	r26, 0x01	; 1
 108:	e0 e0       	ldi	r30, 0x00	; 0
 10a:	f1 e0       	ldi	r31, 0x01	; 1
 10c:	80 e1       	ldi	r24, 0x10	; 16
 10e:	01 90       	ld	r0, Z+
 110:	0d 92       	st	X+, r0
 112:	81 50       	subi	r24, 0x01	; 1
 114:	e1 f7       	brne	.-8      	; 0x10e <main+0x24>
	int i = 0;
	uint8_t switcha;
	HBR_initialise();
 116:	0e 94 bf 01 	call	0x37e	; 0x37e <HBR_initialise>
	Stepper_initialise();
 11a:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <Stepper_initialise>
	sensor_initialise();
 11e:	0e 94 00 02 	call	0x400	; 0x400 <sensor_initialise>


	North_Step_To_Home_Test();
 122:	0e 94 34 01 	call	0x268	; 0x268 <North_Step_To_Home_Test>

		}

		if (switcha != 8){
			STEPA_PORT |= (1<<DIR); // set dir to 1
			StepToPos(swNpos[switcha]);
 126:	7e 01       	movw	r14, r28
 128:	08 94       	sec
 12a:	e1 1c       	adc	r14, r1
 12c:	f1 1c       	adc	r15, r1
	
	//sleep(500);
	
	while(1){
		
		if (north_home() == 1){
 12e:	0e 94 0b 02 	call	0x416	; 0x416 <north_home>
 132:	01 97       	sbiw	r24, 0x01	; 1
 134:	71 f4       	brne	.+28     	; 0x152 <main+0x68>
			North_Step_To_Home_Test();
 136:	0e 94 34 01 	call	0x268	; 0x268 <North_Step_To_Home_Test>
 13a:	0b c0       	rjmp	.+22     	; 0x152 <main+0x68>
			}
			
		while (north_home() == 0 && check_switchs(0) == 8){
			//sleep

			sleep(1000);
 13c:	88 ee       	ldi	r24, 0xE8	; 232
 13e:	93 e0       	ldi	r25, 0x03	; 3
 140:	0e 94 67 00 	call	0xce	; 0xce <sleep>
			switcha = check_switchs(0);
 144:	80 e0       	ldi	r24, 0x00	; 0
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	0e 94 24 02 	call	0x448	; 0x448 <check_switchs>
 14c:	18 2f       	mov	r17, r24
			if (switcha != 8)
 14e:	88 30       	cpi	r24, 0x08	; 8
 150:	61 f4       	brne	.+24     	; 0x16a <main+0x80>
		
		if (north_home() == 1){
			North_Step_To_Home_Test();
			}
			
		while (north_home() == 0 && check_switchs(0) == 8){
 152:	0e 94 0b 02 	call	0x416	; 0x416 <north_home>
 156:	89 2b       	or	r24, r25
 158:	31 f4       	brne	.+12     	; 0x166 <main+0x7c>
 15a:	80 e0       	ldi	r24, 0x00	; 0
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	0e 94 24 02 	call	0x448	; 0x448 <check_switchs>
 162:	08 97       	sbiw	r24, 0x08	; 8
 164:	59 f3       	breq	.-42     	; 0x13c <main+0x52>
			if (switcha != 8)
				break;

		}

		if (switcha != 8){
 166:	18 30       	cpi	r17, 0x08	; 8
 168:	59 f0       	breq	.+22     	; 0x180 <main+0x96>
			STEPA_PORT |= (1<<DIR); // set dir to 1
 16a:	1c 9a       	sbi	0x03, 4	; 3
			StepToPos(swNpos[switcha]);
 16c:	e1 2f       	mov	r30, r17
 16e:	f0 e0       	ldi	r31, 0x00	; 0
 170:	ee 0f       	add	r30, r30
 172:	ff 1f       	adc	r31, r31
 174:	ee 0d       	add	r30, r14
 176:	ff 1d       	adc	r31, r15
 178:	80 81       	ld	r24, Z
 17a:	91 81       	ldd	r25, Z+1	; 0x01
 17c:	0e 94 13 01 	call	0x226	; 0x226 <StepToPos>
		}
		sleep(250);
 180:	8a ef       	ldi	r24, 0xFA	; 250
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	0e 94 67 00 	call	0xce	; 0xce <sleep>
		north_in();
 188:	0e 94 d6 01 	call	0x3ac	; 0x3ac <north_in>
		sleep(500);
 18c:	84 ef       	ldi	r24, 0xF4	; 244
 18e:	91 e0       	ldi	r25, 0x01	; 1
 190:	0e 94 67 00 	call	0xce	; 0xce <sleep>
		north_out();
 194:	0e 94 c8 01 	call	0x390	; 0x390 <north_out>
		STEPA_PORT &= ~(1<<DIR); // set dir to 0
 198:	1c 98       	cbi	0x03, 4	; 3
		North_Step_To_Home_Test();
 19a:	0e 94 34 01 	call	0x268	; 0x268 <North_Step_To_Home_Test>
 19e:	c7 cf       	rjmp	.-114    	; 0x12e <main+0x44>

000001a0 <Stepper_initialise>:

static int pos;

//function definitions
void Stepper_initialise(){
	STEPA_DDR |= STEPPER_MASK;
 1a0:	82 b1       	in	r24, 0x02	; 2
 1a2:	8c 6f       	ori	r24, 0xFC	; 252
 1a4:	82 b9       	out	0x02, r24	; 2



*/

	STEPA_PORT |= (1<< VDD) | (1<<RESET)|(1<<ENABLE)  | (1<<MS1) ;
 1a6:	83 b1       	in	r24, 0x03	; 3
 1a8:	87 62       	ori	r24, 0x27	; 39
 1aa:	83 b9       	out	0x03, r24	; 3
	STEPA_PORT &= ~(1<<STEP)|~(1<<DIR);
 1ac:	83 b1       	in	r24, 0x03	; 3
 1ae:	83 b9       	out	0x03, r24	; 3
//	STEPCD_PORT |= (1<<ENBLN) | (1<<RESET); 
//	STEPCD_PORT &= ~(1<<DIR) | (1<<DECAY)| (1<< BUSM0) | (1<<BUSM1);

}
 1b0:	08 95       	ret

000001b2 <Step>:

void Step(uint8_t dir, uint16_t steps){
 1b2:	cf 93       	push	r28
 1b4:	df 93       	push	r29
	
	uint8_t delta;
	if (dir == 1){
 1b6:	81 30       	cpi	r24, 0x01	; 1
 1b8:	11 f4       	brne	.+4      	; 0x1be <Step+0xc>
		STEPA_PORT |= (1<<DIR);
 1ba:	1c 9a       	sbi	0x03, 4	; 3
 1bc:	06 c0       	rjmp	.+12     	; 0x1ca <Step+0x18>
		delta = 1;
		}
	if (dir == 0){
 1be:	88 23       	and	r24, r24
 1c0:	11 f0       	breq	.+4      	; 0x1c6 <Step+0x14>
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	02 c0       	rjmp	.+4      	; 0x1ca <Step+0x18>
		STEPA_PORT &= ~(1<<DIR);
 1c6:	1c 98       	cbi	0x03, 4	; 3
 1c8:	8f ef       	ldi	r24, 0xFF	; 255
		delta = -1;
		}
	STEPA_PORT &= ~(1<<ENABLE); //enable stepper output
 1ca:	1d 98       	cbi	0x03, 5	; 3
 1cc:	e0 91 10 01 	lds	r30, 0x0110
 1d0:	f0 91 11 01 	lds	r31, 0x0111
 1d4:	40 e0       	ldi	r20, 0x00	; 0
 1d6:	50 e0       	ldi	r21, 0x00	; 0

	for (uint16_t i = 0; i < steps; i++){
		pos += delta;
 1d8:	a8 2f       	mov	r26, r24
 1da:	b0 e0       	ldi	r27, 0x00	; 0
 1dc:	c0 ea       	ldi	r28, 0xA0	; 160
 1de:	df e0       	ldi	r29, 0x0F	; 15
 1e0:	17 c0       	rjmp	.+46     	; 0x210 <Step+0x5e>
 1e2:	ea 0f       	add	r30, r26
 1e4:	fb 1f       	adc	r31, r27
		STEPA_PORT |= (1<<STEP); // send 1 step
 1e6:	1b 9a       	sbi	0x03, 3	; 3
 1e8:	20 e0       	ldi	r18, 0x00	; 0
 1ea:	ce 01       	movw	r24, r28
 1ec:	01 97       	sbiw	r24, 0x01	; 1
 1ee:	f1 f7       	brne	.-4      	; 0x1ec <Step+0x3a>
		for (uint8_t i = 0; i < 50; i++)
 1f0:	2f 5f       	subi	r18, 0xFF	; 255
 1f2:	22 33       	cpi	r18, 0x32	; 50
 1f4:	d1 f7       	brne	.-12     	; 0x1ea <Step+0x38>
			_delay_ms(1);
		STEPA_PORT &= ~(1<<STEP); // end 1 step
 1f6:	1b 98       	cbi	0x03, 3	; 3
 1f8:	20 e0       	ldi	r18, 0x00	; 0
 1fa:	ce 01       	movw	r24, r28
 1fc:	01 97       	sbiw	r24, 0x01	; 1
 1fe:	f1 f7       	brne	.-4      	; 0x1fc <Step+0x4a>
		for (uint8_t i = 0; i < 50; i++)
 200:	2f 5f       	subi	r18, 0xFF	; 255
 202:	22 33       	cpi	r18, 0x32	; 50
 204:	d1 f7       	brne	.-12     	; 0x1fa <Step+0x48>
			_delay_ms(1);
		if (i > steps) break;
 206:	64 17       	cp	r22, r20
 208:	75 07       	cpc	r23, r21
 20a:	28 f0       	brcs	.+10     	; 0x216 <Step+0x64>
		STEPA_PORT &= ~(1<<DIR);
		delta = -1;
		}
	STEPA_PORT &= ~(1<<ENABLE); //enable stepper output

	for (uint16_t i = 0; i < steps; i++){
 20c:	4f 5f       	subi	r20, 0xFF	; 255
 20e:	5f 4f       	sbci	r21, 0xFF	; 255
 210:	46 17       	cp	r20, r22
 212:	57 07       	cpc	r21, r23
 214:	30 f3       	brcs	.-52     	; 0x1e2 <Step+0x30>
 216:	f0 93 11 01 	sts	0x0111, r31
 21a:	e0 93 10 01 	sts	0x0110, r30
			_delay_ms(1);
		if (i > steps) break;
	}


	STEPA_PORT |= (1<<ENABLE); // disable stepper
 21e:	1d 9a       	sbi	0x03, 5	; 3

}
 220:	df 91       	pop	r29
 222:	cf 91       	pop	r28
 224:	08 95       	ret

00000226 <StepToPos>:

void StepToPos( int intenpos){
	uint8_t delta = 1;
	STEPA_PORT &= ~(1<<ENABLE);
 226:	1d 98       	cbi	0x03, 5	; 3
	STEPA_PORT |= (1<<DIR); //direction = 1
 228:	1c 9a       	sbi	0x03, 4	; 3
 22a:	40 91 10 01 	lds	r20, 0x0110
 22e:	50 91 11 01 	lds	r21, 0x0111
 232:	9a 01       	movw	r18, r20
 234:	60 ea       	ldi	r22, 0xA0	; 160
 236:	7f e0       	ldi	r23, 0x0F	; 15
 238:	0a c0       	rjmp	.+20     	; 0x24e <StepToPos+0x28>
			//STEPA_PORT &= ~(1<<DIR); //dir = 0
		}
		*/
		 //enable stepper output
		pos += delta;
		STEPA_PORT |= (1<<STEP); // send 1 step
 23a:	1b 9a       	sbi	0x03, 3	; 3
 23c:	fb 01       	movw	r30, r22
 23e:	31 97       	sbiw	r30, 0x01	; 1
 240:	f1 f7       	brne	.-4      	; 0x23e <StepToPos+0x18>
		//for (uint8_t i = 0; i < 500; i++)
			_delay_ms(1);
		STEPA_PORT &= ~(1<<STEP); // end 1 step
 242:	1b 98       	cbi	0x03, 3	; 3
 244:	fb 01       	movw	r30, r22
 246:	31 97       	sbiw	r30, 0x01	; 1
 248:	f1 f7       	brne	.-4      	; 0x246 <StepToPos+0x20>
 24a:	2f 5f       	subi	r18, 0xFF	; 255
 24c:	3f 4f       	sbci	r19, 0xFF	; 255

void StepToPos( int intenpos){
	uint8_t delta = 1;
	STEPA_PORT &= ~(1<<ENABLE);
	STEPA_PORT |= (1<<DIR); //direction = 1
	while (pos != intenpos){
 24e:	28 17       	cp	r18, r24
 250:	39 07       	cpc	r19, r25
 252:	99 f7       	brne	.-26     	; 0x23a <StepToPos+0x14>
 254:	24 1b       	sub	r18, r20
 256:	35 0b       	sbc	r19, r21
 258:	24 0f       	add	r18, r20
 25a:	35 1f       	adc	r19, r21
 25c:	30 93 11 01 	sts	0x0111, r19
 260:	20 93 10 01 	sts	0x0110, r18
			_delay_ms(1);

	

		}
	STEPA_PORT |= (1<<ENABLE);
 264:	1d 9a       	sbi	0x03, 5	; 3
}
 266:	08 95       	ret

00000268 <North_Step_To_Home_Test>:
	
	STEPA_PORT |= (1<<ENABLE); // disable stepper

}

void North_Step_To_Home_Test(){
 268:	cf 93       	push	r28
 26a:	df 93       	push	r29
	uint8_t home;
	STEPA_PORT &= ~(1<<DIR);
 26c:	1c 98       	cbi	0x03, 4	; 3
 26e:	c0 ea       	ldi	r28, 0xA0	; 160
 270:	df e0       	ldi	r29, 0x0F	; 15

	while(1){
		STEPA_PORT &= ~(1<<ENABLE); //enable stepper output
 272:	1d 98       	cbi	0x03, 5	; 3
		STEPA_PORT &= ~(1<<DIR);
 274:	1c 98       	cbi	0x03, 4	; 3
 276:	20 e0       	ldi	r18, 0x00	; 0
 278:	30 e0       	ldi	r19, 0x00	; 0
		for (uint16_t i = 0; i < 10; i++){
			STEPA_PORT |= (1<<STEP); // send 1 step
 27a:	1b 9a       	sbi	0x03, 3	; 3
 27c:	ce 01       	movw	r24, r28
 27e:	01 97       	sbiw	r24, 0x01	; 1
 280:	f1 f7       	brne	.-4      	; 0x27e <North_Step_To_Home_Test+0x16>
			//for (uint8_t i = 0; i < 500; i++)
				_delay_ms(1);
			STEPA_PORT &= ~(1<<STEP); // end 1 step
 282:	1b 98       	cbi	0x03, 3	; 3
 284:	ce 01       	movw	r24, r28
 286:	01 97       	sbiw	r24, 0x01	; 1
 288:	f1 f7       	brne	.-4      	; 0x286 <North_Step_To_Home_Test+0x1e>
	STEPA_PORT &= ~(1<<DIR);

	while(1){
		STEPA_PORT &= ~(1<<ENABLE); //enable stepper output
		STEPA_PORT &= ~(1<<DIR);
		for (uint16_t i = 0; i < 10; i++){
 28a:	2f 5f       	subi	r18, 0xFF	; 255
 28c:	3f 4f       	sbci	r19, 0xFF	; 255
 28e:	2a 30       	cpi	r18, 0x0A	; 10
 290:	31 05       	cpc	r19, r1
 292:	99 f7       	brne	.-26     	; 0x27a <North_Step_To_Home_Test+0x12>
			STEPA_PORT &= ~(1<<STEP); // end 1 step
			//for (uint8_t i = 0; i < 500; i++)
				_delay_ms(1);
		}
	
	home = north_home();
 294:	0e 94 0b 02 	call	0x416	; 0x416 <north_home>
	if (home == 0)//de bounce check
 298:	88 23       	and	r24, r24
 29a:	59 f7       	brne	.-42     	; 0x272 <North_Step_To_Home_Test+0xa>
				break;
		

	}
	STEPA_PORT |= (1<<ENABLE); // disable stepper
 29c:	1d 9a       	sbi	0x03, 5	; 3
	pos = 0;
 29e:	10 92 11 01 	sts	0x0111, r1
 2a2:	10 92 10 01 	sts	0x0110, r1
}
 2a6:	df 91       	pop	r29
 2a8:	cf 91       	pop	r28
 2aa:	08 95       	ret

000002ac <North_Step_To_Home>:

		}
	STEPA_PORT |= (1<<ENABLE);
}

void North_Step_To_Home(){
 2ac:	0f 93       	push	r16
 2ae:	1f 93       	push	r17
 2b0:	cf 93       	push	r28
 2b2:	df 93       	push	r29

	if (north_home() == 1) return;
 2b4:	0e 94 0b 02 	call	0x416	; 0x416 <north_home>
 2b8:	01 97       	sbiw	r24, 0x01	; 1
 2ba:	f9 f0       	breq	.+62     	; 0x2fa <North_Step_To_Home+0x4e>

	STEPA_PORT &= ~(1<<DIR); // set dir to 0
 2bc:	1c 98       	cbi	0x03, 4	; 3
	STEPA_PORT &= ~(1<<ENABLE); // enable stepper
 2be:	1d 98       	cbi	0x03, 5	; 3
 2c0:	c0 ea       	ldi	r28, 0xA0	; 160
 2c2:	df e0       	ldi	r29, 0x0F	; 15
	while(1){
		STEPA_PORT &= ~(1<<DIR); // set dir to 0
 2c4:	00 e4       	ldi	r16, 0x40	; 64
 2c6:	1c e9       	ldi	r17, 0x9C	; 156
 2c8:	1c 98       	cbi	0x03, 4	; 3
 2ca:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i = 0; i < 100; i++){
			STEPA_PORT |= (1<<STEP); // send 1 step
 2cc:	1b 9a       	sbi	0x03, 3	; 3
 2ce:	ce 01       	movw	r24, r28
 2d0:	01 97       	sbiw	r24, 0x01	; 1
 2d2:	f1 f7       	brne	.-4      	; 0x2d0 <North_Step_To_Home+0x24>
			_delay_ms(1);
			STEPA_PORT &= ~(1<<STEP); // end 1 step
 2d4:	1b 98       	cbi	0x03, 3	; 3
 2d6:	ce 01       	movw	r24, r28
 2d8:	01 97       	sbiw	r24, 0x01	; 1
 2da:	f1 f7       	brne	.-4      	; 0x2d8 <North_Step_To_Home+0x2c>

	STEPA_PORT &= ~(1<<DIR); // set dir to 0
	STEPA_PORT &= ~(1<<ENABLE); // enable stepper
	while(1){
		STEPA_PORT &= ~(1<<DIR); // set dir to 0
		for (uint8_t i = 0; i < 100; i++){
 2dc:	2f 5f       	subi	r18, 0xFF	; 255
 2de:	24 36       	cpi	r18, 0x64	; 100
 2e0:	a9 f7       	brne	.-22     	; 0x2cc <North_Step_To_Home+0x20>
			STEPA_PORT |= (1<<STEP); // send 1 step
			_delay_ms(1);
			STEPA_PORT &= ~(1<<STEP); // end 1 step
			_delay_ms(1);
		}
		if (north_home() == 1){
 2e2:	0e 94 0b 02 	call	0x416	; 0x416 <north_home>
 2e6:	01 97       	sbiw	r24, 0x01	; 1
 2e8:	79 f7       	brne	.-34     	; 0x2c8 <North_Step_To_Home+0x1c>
 2ea:	c8 01       	movw	r24, r16
 2ec:	01 97       	sbiw	r24, 0x01	; 1
 2ee:	f1 f7       	brne	.-4      	; 0x2ec <North_Step_To_Home+0x40>
			_delay_ms(10);
			if (north_home() == 1)//de bounce check
 2f0:	0e 94 0b 02 	call	0x416	; 0x416 <north_home>
 2f4:	01 97       	sbiw	r24, 0x01	; 1
 2f6:	41 f7       	brne	.-48     	; 0x2c8 <North_Step_To_Home+0x1c>
				break;
		}
	} 
	
	STEPA_PORT |= (1<<ENABLE); // disable stepper
 2f8:	1d 9a       	sbi	0x03, 5	; 3

}
 2fa:	df 91       	pop	r29
 2fc:	cf 91       	pop	r28
 2fe:	1f 91       	pop	r17
 300:	0f 91       	pop	r16
 302:	08 95       	ret

00000304 <South_Step_To_Home>:
	}
	STEPA_PORT |= (1<<ENABLE); // disable stepper
	pos = 0;
}

void South_Step_To_Home(){
 304:	0f 93       	push	r16
 306:	1f 93       	push	r17
 308:	cf 93       	push	r28
 30a:	df 93       	push	r29
//TODO: change to stepb port
	//if (north_home() == 0) return;
	STEPA_PORT |= (1<<DIR); // set dir to 0
 30c:	1c 9a       	sbi	0x03, 4	; 3
	STEPA_PORT &= ~(1<<ENABLE); // enable stepper
 30e:	1d 98       	cbi	0x03, 5	; 3
 310:	00 e2       	ldi	r16, 0x20	; 32
 312:	1e e4       	ldi	r17, 0x4E	; 78
	while(1){
		STEPA_PORT |= (1<<DIR); // set dir to 0
 314:	c0 e4       	ldi	r28, 0x40	; 64
 316:	dc e9       	ldi	r29, 0x9C	; 156
 318:	1c 9a       	sbi	0x03, 4	; 3
 31a:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i = 0; i < 10; i++){
			STEPA_PORT |= (1<<STEP); // send 1 step
 31c:	1b 9a       	sbi	0x03, 3	; 3
 31e:	c8 01       	movw	r24, r16
 320:	01 97       	sbiw	r24, 0x01	; 1
 322:	f1 f7       	brne	.-4      	; 0x320 <South_Step_To_Home+0x1c>
			_delay_ms(5);
			STEPA_PORT &= ~(1<<STEP); // end 1 step
 324:	1b 98       	cbi	0x03, 3	; 3
 326:	c8 01       	movw	r24, r16
 328:	01 97       	sbiw	r24, 0x01	; 1
 32a:	f1 f7       	brne	.-4      	; 0x328 <South_Step_To_Home+0x24>
	//if (north_home() == 0) return;
	STEPA_PORT |= (1<<DIR); // set dir to 0
	STEPA_PORT &= ~(1<<ENABLE); // enable stepper
	while(1){
		STEPA_PORT |= (1<<DIR); // set dir to 0
		for (uint8_t i = 0; i < 10; i++){
 32c:	2f 5f       	subi	r18, 0xFF	; 255
 32e:	2a 30       	cpi	r18, 0x0A	; 10
 330:	a9 f7       	brne	.-22     	; 0x31c <South_Step_To_Home+0x18>
			STEPA_PORT |= (1<<STEP); // send 1 step
			_delay_ms(5);
			STEPA_PORT &= ~(1<<STEP); // end 1 step
			_delay_ms(5);
		}
		if (north_home() == 1){
 332:	0e 94 0b 02 	call	0x416	; 0x416 <north_home>
 336:	01 97       	sbiw	r24, 0x01	; 1
 338:	79 f7       	brne	.-34     	; 0x318 <South_Step_To_Home+0x14>
 33a:	ce 01       	movw	r24, r28
 33c:	01 97       	sbiw	r24, 0x01	; 1
 33e:	f1 f7       	brne	.-4      	; 0x33c <South_Step_To_Home+0x38>
			_delay_ms(10);
			if (south_home() == 1){//de bounce check
 340:	0e 94 1f 02 	call	0x43e	; 0x43e <south_home>
 344:	01 97       	sbiw	r24, 0x01	; 1
 346:	41 f7       	brne	.-48     	; 0x318 <South_Step_To_Home+0x14>
 348:	ce 01       	movw	r24, r28
 34a:	01 97       	sbiw	r24, 0x01	; 1
 34c:	f1 f7       	brne	.-4      	; 0x34a <South_Step_To_Home+0x46>
				_delay_ms(10);
				if (south_home() == 1){//de bounce check
 34e:	0e 94 1f 02 	call	0x43e	; 0x43e <south_home>
 352:	01 97       	sbiw	r24, 0x01	; 1
 354:	09 f7       	brne	.-62     	; 0x318 <South_Step_To_Home+0x14>
 356:	ce 01       	movw	r24, r28
 358:	01 97       	sbiw	r24, 0x01	; 1
 35a:	f1 f7       	brne	.-4      	; 0x358 <South_Step_To_Home+0x54>
					_delay_ms(10);
					if (south_home() == 1){//de bounce check
 35c:	0e 94 1f 02 	call	0x43e	; 0x43e <south_home>
 360:	01 97       	sbiw	r24, 0x01	; 1
 362:	d1 f6       	brne	.-76     	; 0x318 <South_Step_To_Home+0x14>
 364:	ce 01       	movw	r24, r28
 366:	01 97       	sbiw	r24, 0x01	; 1
 368:	f1 f7       	brne	.-4      	; 0x366 <South_Step_To_Home+0x62>
						_delay_ms(10);
							if (south_home() == 1)
 36a:	0e 94 1f 02 	call	0x43e	; 0x43e <south_home>
 36e:	01 97       	sbiw	r24, 0x01	; 1
 370:	99 f6       	brne	.-90     	; 0x318 <South_Step_To_Home+0x14>
				}
			}
		}
	} 
	
	STEPA_PORT |= (1<<ENABLE); // disable stepper
 372:	1d 9a       	sbi	0x03, 5	; 3

}
 374:	df 91       	pop	r29
 376:	cf 91       	pop	r28
 378:	1f 91       	pop	r17
 37a:	0f 91       	pop	r16
 37c:	08 95       	ret

0000037e <HBR_initialise>:
void HBR_initialise();


//function definitions
void HBR_initialise(){
	HBRDDR |= HBR_MASK;
 37e:	8a b3       	in	r24, 0x1a	; 26
 380:	8f ef       	ldi	r24, 0xFF	; 255
 382:	8a bb       	out	0x1a, r24	; 26
#define TWO_ONEP 1 //T8
#define TWO_TWON 0 //T4//two neg direction
#define TWO_TWOP 3 //T7
*/

	HBRPORT |= (1<< ONE_ONEP) | (1<<ONE_TWOP) | (1<<TWO_ONEP) | (1<<TWO_TWOP);
 384:	8b b3       	in	r24, 0x1b	; 27
 386:	8a 6a       	ori	r24, 0xAA	; 170
 388:	8b bb       	out	0x1b, r24	; 27
	HBRPORT &= ~(1<< ONE_ONEN) | ~(1<<ONE_TWON) | ~(1<<TWO_ONEN) | ~(1<<TWO_TWON);
 38a:	8b b3       	in	r24, 0x1b	; 27
 38c:	8b bb       	out	0x1b, r24	; 27
}
 38e:	08 95       	ret

00000390 <north_out>:

void north_out(){
	HBRPORT |= (1<<ONE_ONEN);
 390:	de 9a       	sbi	0x1b, 6	; 27
	HBRPORT &= ~(1<<ONE_ONEP);//turn on motor
 392:	dd 98       	cbi	0x1b, 5	; 27
 394:	20 e0       	ldi	r18, 0x00	; 0
 396:	40 e4       	ldi	r20, 0x40	; 64
 398:	5c e9       	ldi	r21, 0x9C	; 156
 39a:	ca 01       	movw	r24, r20
 39c:	01 97       	sbiw	r24, 0x01	; 1
 39e:	f1 f7       	brne	.-4      	; 0x39c <north_out+0xc>
	for (uint8_t i = 0; i < 100; i++){
 3a0:	2f 5f       	subi	r18, 0xFF	; 255
 3a2:	24 36       	cpi	r18, 0x64	; 100
 3a4:	d1 f7       	brne	.-12     	; 0x39a <north_out+0xa>
		_delay_ms(10);
	}
	HBRPORT |= (1<<ONE_ONEP);
 3a6:	dd 9a       	sbi	0x1b, 5	; 27
	HBRPORT &= ~(1<<ONE_ONEN);//turn off motor
 3a8:	de 98       	cbi	0x1b, 6	; 27


}
 3aa:	08 95       	ret

000003ac <north_in>:

void north_in(){
	HBRPORT |= (1<<ONE_TWON);
 3ac:	dc 9a       	sbi	0x1b, 4	; 27
	HBRPORT &= ~(1<<ONE_TWOP);//turn on motor
 3ae:	df 98       	cbi	0x1b, 7	; 27
 3b0:	20 e0       	ldi	r18, 0x00	; 0
 3b2:	40 e4       	ldi	r20, 0x40	; 64
 3b4:	5c e9       	ldi	r21, 0x9C	; 156
 3b6:	ca 01       	movw	r24, r20
 3b8:	01 97       	sbiw	r24, 0x01	; 1
 3ba:	f1 f7       	brne	.-4      	; 0x3b8 <north_in+0xc>
	for (uint8_t i = 0; i < 100; i++){
 3bc:	2f 5f       	subi	r18, 0xFF	; 255
 3be:	24 36       	cpi	r18, 0x64	; 100
 3c0:	d1 f7       	brne	.-12     	; 0x3b6 <north_in+0xa>
		_delay_ms(10);
	}
	HBRPORT |= (1<<ONE_TWOP);//turn off motor
 3c2:	df 9a       	sbi	0x1b, 7	; 27
	HBRPORT &= ~(1<<ONE_TWON);
 3c4:	dc 98       	cbi	0x1b, 4	; 27
}
 3c6:	08 95       	ret

000003c8 <south_out>:

void south_out(){
	HBRPORT |= (1<<TWO_ONEN);
 3c8:	da 9a       	sbi	0x1b, 2	; 27
	HBRPORT &= ~(1<<TWO_ONEP);//turn on motor
 3ca:	d9 98       	cbi	0x1b, 1	; 27
 3cc:	20 e0       	ldi	r18, 0x00	; 0
 3ce:	40 e4       	ldi	r20, 0x40	; 64
 3d0:	5c e9       	ldi	r21, 0x9C	; 156
 3d2:	ca 01       	movw	r24, r20
 3d4:	01 97       	sbiw	r24, 0x01	; 1
 3d6:	f1 f7       	brne	.-4      	; 0x3d4 <south_out+0xc>
	for (uint8_t i = 0; i < 100; i++){
 3d8:	2f 5f       	subi	r18, 0xFF	; 255
 3da:	24 36       	cpi	r18, 0x64	; 100
 3dc:	d1 f7       	brne	.-12     	; 0x3d2 <south_out+0xa>
		_delay_ms(10);
	}
	HBRPORT |= (1<<TWO_ONEP);
 3de:	d9 9a       	sbi	0x1b, 1	; 27
	HBRPORT &= ~(1<<TWO_ONEN);//turn off motor
 3e0:	da 98       	cbi	0x1b, 2	; 27


}
 3e2:	08 95       	ret

000003e4 <south_in>:

void south_in(){
	HBRPORT |= (1<<TWO_TWON);
 3e4:	d8 9a       	sbi	0x1b, 0	; 27
	HBRPORT &= ~(1<<TWO_TWOP);//turn on motor
 3e6:	db 98       	cbi	0x1b, 3	; 27
 3e8:	20 e0       	ldi	r18, 0x00	; 0
 3ea:	40 e4       	ldi	r20, 0x40	; 64
 3ec:	5c e9       	ldi	r21, 0x9C	; 156
 3ee:	ca 01       	movw	r24, r20
 3f0:	01 97       	sbiw	r24, 0x01	; 1
 3f2:	f1 f7       	brne	.-4      	; 0x3f0 <south_in+0xc>
	for (uint8_t i = 0; i < 100; i++){
 3f4:	2f 5f       	subi	r18, 0xFF	; 255
 3f6:	24 36       	cpi	r18, 0x64	; 100
 3f8:	d1 f7       	brne	.-12     	; 0x3ee <south_in+0xa>
		_delay_ms(10);
	}
	HBRPORT |= (1<<TWO_TWOP);//turn off motor
 3fa:	db 9a       	sbi	0x1b, 3	; 27
	HBRPORT &= ~(1<<TWO_TWON);
 3fc:	d8 98       	cbi	0x1b, 0	; 27

}
 3fe:	08 95       	ret

00000400 <sensor_initialise>:
uint8_t south_home();
uint8_t check_switchs(uint8_t current);

void sensor_initialise(){

	SENSOR_DDR = SENSOR_MASK;
 400:	10 92 61 00 	sts	0x0061, r1
	SENSOR_PORT |= (1<<NORTH_HOME) | (1<<SOUTH_HOME);
 404:	e2 e6       	ldi	r30, 0x62	; 98
 406:	f0 e0       	ldi	r31, 0x00	; 0
 408:	80 81       	ld	r24, Z
 40a:	83 60       	ori	r24, 0x03	; 3
 40c:	80 83       	st	Z, r24

	SWITCH_DDR = SENSOR_MASK;
 40e:	17 ba       	out	0x17, r1	; 23
	SWITCH_PORT = 0xFF;
 410:	8f ef       	ldi	r24, 0xFF	; 255
 412:	88 bb       	out	0x18, r24	; 24

	

}
 414:	08 95       	ret

00000416 <north_home>:
 416:	40 e2       	ldi	r20, 0x20	; 32
 418:	5e e4       	ldi	r21, 0x4E	; 78
uint8_t north_home(){
	uint8_t home;
	uint8_t home2;
	uint8_t home3;
	while(1){
		home = SENSOR_PIN & (1<<NORTH_HOME);
 41a:	20 b1       	in	r18, 0x00	; 0
 41c:	21 70       	andi	r18, 0x01	; 1
 41e:	ca 01       	movw	r24, r20
 420:	01 97       	sbiw	r24, 0x01	; 1
 422:	f1 f7       	brne	.-4      	; 0x420 <north_home+0xa>
		_delay_ms(5);
		home2 = SENSOR_PIN & (1<<NORTH_HOME);
 424:	80 b1       	in	r24, 0x00	; 0
 426:	fa 01       	movw	r30, r20
 428:	31 97       	sbiw	r30, 0x01	; 1
 42a:	f1 f7       	brne	.-4      	; 0x428 <north_home+0x12>
		_delay_ms(5);
		home3 = SENSOR_PIN & (1<<NORTH_HOME);
 42c:	90 b1       	in	r25, 0x00	; 0
 42e:	91 70       	andi	r25, 0x01	; 1
		if (home == home2 && home == home3)
 430:	81 70       	andi	r24, 0x01	; 1
 432:	28 17       	cp	r18, r24
 434:	91 f7       	brne	.-28     	; 0x41a <north_home+0x4>
 436:	29 17       	cp	r18, r25
 438:	81 f7       	brne	.-32     	; 0x41a <north_home+0x4>
			return home;
		else
			continue;
	}
}
 43a:	82 2f       	mov	r24, r18
 43c:	08 95       	ret

0000043e <south_home>:

uint8_t south_home(){
	uint8_t home;

	home = SENSOR_PIN & (1<<SOUTH_HOME);
 43e:	80 b1       	in	r24, 0x00	; 0
 440:	86 95       	lsr	r24
 442:	80 95       	com	r24
	
	if (home)
		return 0; // not at home
	else
		return 1; // at home
}
 444:	81 70       	andi	r24, 0x01	; 1
 446:	08 95       	ret

00000448 <check_switchs>:


uint8_t check_switchs(uint8_t current){//input 0 or 1
	uint8_t switchno;
	
		switchno = SWITCH_PIN & (1<<0);
 448:	26 b3       	in	r18, 0x16	; 22
 44a:	21 70       	andi	r18, 0x01	; 1
		if (switchno != current) // check if switch is same as current
 44c:	28 17       	cp	r18, r24
 44e:	11 f0       	breq	.+4      	; 0x454 <check_switchs+0xc>
 450:	80 e0       	ldi	r24, 0x00	; 0
 452:	08 95       	ret
			return 0; 	//if it's not, return that switch
		switchno = SWITCH_PIN & (1<<1);
 454:	96 b3       	in	r25, 0x16	; 22
 456:	92 70       	andi	r25, 0x02	; 2
		if (switchno != current) // check if switch is same as current
 458:	92 17       	cp	r25, r18
 45a:	11 f0       	breq	.+4      	; 0x460 <check_switchs+0x18>
 45c:	81 e0       	ldi	r24, 0x01	; 1
 45e:	08 95       	ret
			return 1; 	//if it's not, return that switch
		switchno = SWITCH_PIN & (1<<2);
 460:	86 b3       	in	r24, 0x16	; 22
 462:	84 70       	andi	r24, 0x04	; 4
		if (switchno != current) // check if switch is same as current
 464:	89 17       	cp	r24, r25
 466:	11 f0       	breq	.+4      	; 0x46c <check_switchs+0x24>
 468:	82 e0       	ldi	r24, 0x02	; 2
 46a:	08 95       	ret
			return 2; 	//if it's not, return that switch
		switchno = SWITCH_PIN & (1<<3);
 46c:	96 b3       	in	r25, 0x16	; 22
		if (switchno != current) // check if switch is same as current
 46e:	98 70       	andi	r25, 0x08	; 8
 470:	98 17       	cp	r25, r24
 472:	11 f0       	breq	.+4      	; 0x478 <check_switchs+0x30>
 474:	83 e0       	ldi	r24, 0x03	; 3
 476:	08 95       	ret
			return 3; 	//if it's not, return that switch
		switchno = SWITCH_PIN & (1<<4);
 478:	86 b3       	in	r24, 0x16	; 22
		if (switchno != current) // check if switch is same as current
 47a:	80 71       	andi	r24, 0x10	; 16
 47c:	89 17       	cp	r24, r25
 47e:	11 f0       	breq	.+4      	; 0x484 <check_switchs+0x3c>
 480:	84 e0       	ldi	r24, 0x04	; 4
 482:	08 95       	ret
			return 4; 	//if it's not, return that switch
		switchno = SWITCH_PIN & (1<<5);
 484:	96 b3       	in	r25, 0x16	; 22
		if (switchno != current) // check if switch is same as current
 486:	90 72       	andi	r25, 0x20	; 32
 488:	98 17       	cp	r25, r24
 48a:	11 f0       	breq	.+4      	; 0x490 <check_switchs+0x48>
 48c:	85 e0       	ldi	r24, 0x05	; 5
 48e:	08 95       	ret
			return 5; 	//if it's not, return that switch
		switchno = SWITCH_PIN & (1<<6);
 490:	26 b3       	in	r18, 0x16	; 22
		if (switchno != current) // check if switch is same as current
 492:	20 74       	andi	r18, 0x40	; 64
 494:	29 17       	cp	r18, r25
 496:	11 f0       	breq	.+4      	; 0x49c <check_switchs+0x54>
 498:	86 e0       	ldi	r24, 0x06	; 6
 49a:	08 95       	ret
			return 6; 	//if it's not, return that switch
		switchno = SWITCH_PIN & (1<<7);
 49c:	86 b3       	in	r24, 0x16	; 22
		if (switchno != current) // check if switch is same as current
 49e:	80 78       	andi	r24, 0x80	; 128
 4a0:	82 17       	cp	r24, r18
 4a2:	11 f4       	brne	.+4      	; 0x4a8 <check_switchs+0x60>
 4a4:	88 e0       	ldi	r24, 0x08	; 8
 4a6:	08 95       	ret
 4a8:	87 e0       	ldi	r24, 0x07	; 7
			return 7; 	//if it's not, return that switch

			//hard coded because or problems with variables in bitwise shift
	
	return 8; //if all good
}
 4aa:	08 95       	ret

000004ac <_exit>:
 4ac:	f8 94       	cli

000004ae <__stop_program>:
 4ae:	ff cf       	rjmp	.-2      	; 0x4ae <__stop_program>
